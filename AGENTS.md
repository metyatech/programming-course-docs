<!--
  Generated by agent-rules-tools/tools/compose-agents.cjs.
  Source: agent-ruleset.json
-->
## 言語（返答・記述）

### 回答言語

ユーザーへの最終返答は日本語で書く（ユーザーから別の希望がある場合はそちらを優先）。

### 記述言語

- 特に指定がない限り、開発者向けドキュメント（例: `README.md`）、コードコメント、コミットメッセージは英語で書く。

## 実装・技術選定

- JavaScript ではなく TypeScript を標準とする（`.ts`/`.tsx`）。
- JavaScript は、ツール都合で必要な設定ファイル等に限定する。
- 既存の言語/フレームワーク/依存関係の範囲で完結させる。新規依存追加は必要最小限にする。
- 「既存に合わせる」よりも「理想的な状態（読みやすさ・保守性・一貫性・安全性）」を優先する。
- ただし、目的と釣り合わない大改修や無関係な改善はしない。
- 不明点や判断が分かれる点は、独断で進めず確認する。

### 意思決定の優先順位

保守性 ＞ テスト容易性 ＞ 拡張性 ＞ 可読性

## 設計・実装の原則（共通）

- 責務を小さく保ち、関心を分離する（単一責任）。
- 依存関係の方向を意識し、差し替えが必要な箇所は境界を分離する（抽象化/インターフェース等）。
- 継承より合成を優先し、差分を局所化する（過度な階層化を避ける）。
- グローバルな共有可変状態を増やさない（所有者と寿命が明確な場所へ閉じ込める）。
- 深いネストを避け、ガード節/関数分割で見通しを保つ。
- 意図が分かる命名にする（曖昧な省略や「Utils」的な雑多化を避ける）。
- ハードコードを避け、設定/定数/データへ寄せられるものは寄せる（変更点を1箇所に集約する）。

## コーディング規約

- まずは各リポジトリの既存コード・設定（formatter/linter）に合わせる。
- 明示的な規約がない場合は、対象言語/フレームワークの一般的なベストプラクティスに合わせる。

## AGENTS ルール運用（合成）

### 対象範囲

- この `AGENTS.md` は単独で完結する前提とする。
- 親子ディレクトリの `AGENTS.md` に依存しない（継承/優先の概念は使わない）。
- ルールは共通ルール（`agent-rules/rules/`）として管理し、各プロジェクト直下の `agent-rules/`（git submodule）から参照して合成する。
- プロジェクト固有ルールが必要な場合は、プロジェクト側に `agent-rules-local/` 等で配置し、`agent-ruleset.json` から参照して合成する。

### 更新方針

- ルール変更は `agent-rules/rules/`、プロジェクト固有ルール（例: `agent-rules-local/`）、および `agent-ruleset.json` に対して行い、合成スクリプト（`agent-rules-tools/tools/compose-agents.cjs`）で `AGENTS.md` を再生成する。
- 生成済みの `AGENTS.md` は直接編集しない（編集が必要なら元ルールへ反映する）。
- ユーザーから「ルールを更新して」と依頼された場合、特段の指示がない限り「適切なルールモジュールとルールセットを更新し、再生成する」ことを意味する。
- ユーザーが「常にこうして下さい」など恒常運用の指示を明示した場合は、その指示自体をルールとして適切なモジュールに追記する。

### ルール修正時の注意点

- MECE（相互排他的かつ全体網羅的）に分類し、重複と漏れを作らない。
- 冗長な説明や同じ内容の繰り返しを避ける（必要十分）。
- 手順以外の列挙に番号を振らない（追加/削除で保守が崩れるため）。
- 各セクションの役割を明確にし、「どこに書くべきか」が一目で分かる構成にする。

### AGENTS.md の配置

- 各プロジェクトのルートに `AGENTS.md` を置く。
- サブツリーに別プロジェクトがある場合のみ、そのルートに `AGENTS.md` を置く（同一プロジェクト内で重複配置しない）。

## ドキュメント（README）

- すべてのリポジトリ（モジュール）に `README.md` を置く。
- README には最低限として、概要/目的、セットアップ、開発コマンド（例: build/test/lint）、必要な環境変数/設定、公開/デプロイ手順（該当する場合）を書く。
- ソースコード変更時は、README へ影響がないかを必ず確認する。影響がある場合は同一変更セット内で README を更新する（必須）。
  - 影響例: 使い方/API/挙動、セットアップ手順、開発コマンド、環境変数、設定、公開/デプロイ手順、対応バージョン、破壊的変更。
  - README 更新が不要な場合でも、「なぜ不要か」を最終返答に明記する（独断でスキップしない）。

## 品質（テスト・検証・エラーハンドリング）

### 検証（ビルド/テスト/静的解析）

- 変更に関連する最小範囲のビルド/テスト/静的解析を実行する。
- 実行方法は各リポジトリが用意しているスクリプト/コマンドを優先する（例: `npm run build`, `npm test`）。
- 実行できない場合は、その理由と、ユーザーが実行するコマンドを明記する。

### テスト

- 原則: 挙動が変わる変更（仕様追加/変更/バグ修正/リファクタ等）には、同一変更セット内で自動テスト（ユニット/統合/スナップショット等）を追加/更新する（必須）。
- テスト未整備: 対象リポジトリにテストが存在しない場合は、可能な限り最小のテスト基盤とテストを同一変更セット内で追加する。新規依存追加が必要な場合は、候補と影響範囲を提示してユーザーに確認してから進める。
- 例外: テスト追加が困難/不適切な場合は、理由と代替検証（手動確認手順・実行コマンド等）を明記し、ユーザーに確認してから省略する（独断で省略しない）。
- テストは決定的にする（時刻/乱数/外部I/O/グローバル状態への依存を最小化し、必要なら差し替え可能にする）。

### バグ修正（手順）

バグ修正は原則として、次の順で行う:

1. バグを再現する自動テストを追加/更新し、テストが失敗することを確認する。
2. バグ修正を行う。
3. 関連するテストを実行し、修正によってテストが通ることを確認する。

上記の自動テスト追加が困難な場合は、理由と代替検証手順を明記し、ユーザーに確認してから省略する。

### エラーハンドリング

- 失敗を握りつぶさない（空の catch / 黙殺 / サイレントフォールバックを避ける）。
- 回復可能なら早期 return + 明示的なエラー通知、回復不能なら明確に停止/失敗させる。

### ログ

- ログは冗長にしないが、原因特定に必要なコンテキスト（識別子や入力条件）を含める。
- 秘密情報/個人情報をログに出さない（必要ならマスク/分離する）。

## コマンド実行

- ユーザーが明示しない限り、コマンドにラッパーやパイプを付加しない。
- ビルド/テスト/実行は、各リポジトリの標準スクリプト/手順（`package.json`、README等）を優先する。

## 生成物

- 生成物（例: `build/`, `dist/`, `node_modules/`）は原則コミットしない（各リポジトリの `.gitignore` に従う）。

## ファイル命名

- ファイル名は原則として半角英数の `kebab-case`（スペースなし）に統一する。

## マルチリポジトリ運用

- リポジトリは基本的に独立しており、変更は「影響のあるリポジトリ」に限定して行う。
- 共通モジュール（例: `agent-rules` など）を更新した場合は、利用側リポジトリでも参照（サブモジュールのコミット）を更新し、必要な検証まで同じ変更セットで行う。

## 変更の局所化

- 変更対象（影響範囲）を明確にし、無関係な別リポジトリへ不用意に波及させない。

## 検証

- 変更したリポジトリ内の手元検証を優先する（例: `npm run build`, `npm test`）。
- 共通モジュール側の変更が利用側に影響しうる場合は、少なくとも1つの利用側リポジトリで動作確認（ビルド等）を行う。

## 教材サイト（本文・演習）作成ルール

本ファイルには、教材サイトに共通して適用する「安定したルール」を中心に記載する。
個別事例・暫定判断・可変仕様・特定リポジトリ固有設定は、原則としてこのファイルに書かない。

### 意思決定の優先順位

教材では「学習効果（分かりやすさ・段階性・再現性）」を最優先する。

## 本文・サンプル

- 教材ページ（`docs/` 配下）の本文・ラベル・出力文は日本語で、学習者が理解できる語彙で書く。
- 本文は冗長にしない。長い説明が必要な場合は、短い段落・箇条書き・小見出しで分割し、段階的に進める。
- 編集者向けメモや方針（例: 「ここでは扱わない」「編集メモ: ...」）やメタ的内容（例: 「AIが考える...」）は本文に入れない。
- 用語・見出し構成・説明の粒度は既存ページのパターンに合わせ、学習者が迷わない一貫性を優先する。
- サンプルは「1サンプル=1トピック」を守り、短く単純にする（長くなる場合は分割/段階化）。
- 識別子（変数名・クラス名・`id` 等）は意図が推測できる短い名前にする。1文字変数は原則避ける（例外: `i`, `j`）。
- 出力があるコードは期待値を併記する（例: `console.log(x); // 出力: ...`）。
- コードブロックは言語指定を付ける（例: `js`, `ts`, `html`, `css`）。
- 章の冒頭では「どこで使うか」を1～2文で示して動機付けを行う。
- 実在サイト例を出す場合は、個人情報が表示されるページや認証が必要なページへリンクしない。

## 既習事項の扱い

- 既習/未習の判定は `sidebars.ts` の並び順を基準にする（既習=前のページ + 当該ページ内で説明済み）。
- 未習の API / 構文が必要になる場合は、前提説明を先に追加するか、出題/解説の設計を変更する。

## 主要ディレクトリとページ追加

- 主要: `docs/`（教材）, `sidebars.ts`（並び順）, `docusaurus.config.ts`（設定）, `static/`（サイト全体の静的ファイル）。
- 新規ページは「フォルダ化ページ」に統一し、`docs/<chapter>/<slug>/index.mdx`（コンポーネントを全く使わない場合は `index.md`）に作成する。
  - 先頭に frontmatter（`title`）を設定する。
  - 必要なコンポーネントは frontmatter の直後で import する（MDX）。
- ページを追加/分割した場合は `sidebars.ts` も更新し、既習事項（上記「既習事項の扱い」）と矛盾しない並びにする（迷う場合は末尾追加を基本とする）。

## ページ資材（assets）

- 画像・配布物などページに紐づく資材は、**用途でフォルダを分けず**に「ページ単位」で管理する。
- 各ページは `docs/<chapter>/<slug>/index.mdx` とし、資材は `docs/<chapter>/<slug>/assets/...` に置く。
  - ページ内表示の画像: `![...](./assets/example.png)` のように相対パスで参照する。
  - 配布（ダウンロード）: `<a href={require("./assets/<name>")} download="<name>">...</a>` を使う。
    - `download` を指定しないとハッシュ名になるため、原則として付ける。
    - この教材サイトの構成では、`require("./assets/<name>")` はURL文字列を返す前提（`.default` を付けない）。
- 「同一章内で複数ページ共通」「サイト全体で共通」などの共有置き場は作らない。
  - 複数ページで同じ資材を使い回す場合でも、各ページの `assets/` にコピーして持つ（依存関係を作らない）。

## 付属ファイルのビルド前提（@metyatech/docusaurus-download-assets）

- `docs/**/assets/` 配下の任意拡張子ファイルを `require/import` で扱えるようにするため、教材サイトは `@metyatech/docusaurus-download-assets` を有効化している前提で運用する。
- 付属ファイルを追加したのにビルドで「loader がない / Module parse failed」等が出た場合は、まず当該教材サイトの `package.json` 依存と `docusaurus.config.ts` のプラグイン有効化を確認する。

## CodePreview（@metyatech/code-preview）

- **実行できるサンプルは CodePreview を優先**（単純な構文説明、非実行コードなどは通常のコードブロックでも可）。
- CodePreview のスタイルはコンポーネント側で注入される前提のため、ページ側で `@metyatech/code-preview/styles.css` を import しない。
- 初期コードは、**`<CodePreview>...</CodePreview>` の中（開始タグと終了タグの間）** にフェンスコードブロックで書く。
  - 言語ラベルは `html` / `css` / `js` / `javascript` を使う（省略しない）。
  - `html` ブロックは、原則 **`<body>` の中に置く内容だけ**を書く（`<!DOCTYPE html>` / `<html>` / `<head>` / `<body>` は書かない）。
  - CSS/JS は、原則、それぞれ `css` / `js`（または `javascript`）の **別ブロック**に分ける（HTML に `<style>` / `<script>` を埋め込まない）。
  - CSSは `{}` の前後を改行し、プロパティは `color: red;` のように `:` の後にスペースを入れる。
- CodePreview 内で参照する画像は `images` マップで仮想パス→実パスを渡す（Markdown/MDX の相対パス参照とは別）。
- 複数プレビューで同じ初期コードを共有したい場合は `sourceId` を使う。
  - `sourceId` は衝突を避けるため、ページ内で一意になる短い文字列を推奨（ASCIIでなくても可）。
- 表示制御: `htmlVisible`, `cssVisible`, `jsVisible`, `previewVisible` で各パネルを切り替える。

## 演習（@metyatech/exercise）

- `@metyatech/exercise/client` の `<Exercise>` と `<Solution>` を使用する。
  - `<Solution>` は必ず同一 `<Exercise>` の末尾に配置する。
- タイトル採番: `演習N` / `演習-発展N` を基本とし、後ろに括弧で説明を付けてよい（例: `演習1（?）`、`演習-発展1（?）`）。ページ内で重複や飛び番を作らない。
- 問題文は曖昧さを避け、開始データ・手順・確認方法・完成イメージを明示する（短く書く）。
- 問題文にヒントを入れるのは可。ただし解答に直結するコード/手順/値など「直接的な答え」は書かない（必要なら `<Solution>` 側へ移す）。
- 解答コードは `<Solution>` 内に置き、説明は初学者向けに短く具体的に書く。
- 見た目を作成する演習では、完成イメージを視覚的に提示する（プレビュー表示、提示コード内コメントなど、最も理解しやすい方法を選ぶ）。

### 演習・演習-発展の配置方針

- 各トピックごとに「演習」と「演習-発展」をこまめに配置し、学習直後に実践できるようにする（資料末尾にまとめて配置しない）。
- 「演習」は最低限知っておくべき内容までを目安にし、必要なら複数配置してよい。
- 「演習-発展」はより高いレベルの内容とし、全体を通して後半ほど難易度を上げる（複数配置してよい）。
- 本質的に同じ内容の演習を繰り返さず、多角的な出題にする。

### 演習問題の内容方針

- **演習**: 学習トピックの習得にのみフォーカスし、関係のない不要な要素を含めない。
- **演習-発展**: より実践的でもよいが、学習トピックを中心に習得できる問題にする。

### 演習作成時の既習事項確認と重複回避

演習・演習-発展を作成する際は、必ず以下の手順を踏むこと:

1. **既習事項の確認**: 上記「既習事項の扱い」に従い、未習の API / 構文を使わない設計になっていることを確認する。
2. **既出演習内容の確認**: 同一ページ内および過去ページで既に出題された演習内容を確認する。「表面的な違い」ではなく「本質的な違い（学習ポイント・解法パターン）」があるかで判断する。
3. **本質的重複の判定**: 同じイベント・同じ操作パターン・同じ学習ポイントの組み合わせは「本質的に同じ」とみなす。異なる観点（状態管理、複数イベント、条件分岐、累積変化、複数要素連動など）を持つ問題を作る。
4. **実現可能性確認**: 既習事項のみで解けることを確認する。未習事項が必要／冗長な繰り返しだけになる場合は再設計する。

## テスト・試験（評価問題）

- 設問は1つの解釈・1つの正解になるように、初期状態・操作回数・期待結果を明示する。
- 「切り替わる」など曖昧な語は、状態遷移（例: クリックのたびにトグル／1回目のみ変化）を文章で固定する。
- UI操作を問う設問は、動作イメージ（GIF/静止画）を問題文内に提示して期待動作を固定する（可能なら解答デモを再現してキャプチャ）。
- 穴埋め問題は、答えの形式（値/単位/セレクタ/プロパティ名など）と禁止事項を明示する。
- 外部システムと連携する穴埋めは `${答え}`（複数解は `${/正規表現/}`）の形式で示し、別形式（例: `【1】`）へ置換しない。
- 複数解を許容する場合は、許容範囲（例: `textContent`/`innerText` どちらでも可）を問題文に明記する。
